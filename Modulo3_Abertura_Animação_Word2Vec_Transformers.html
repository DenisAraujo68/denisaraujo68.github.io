<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NLP Evolution: Word2Vec → Transformers</title>
  <style>
    :root{
      --bg:#0b1020;          /* deep night */
      --panel:#121a33;       /* card */
      --ink:#e9eefc;         /* text */
      --muted:#9fb1ff;       /* secondary text */
      --accent:#7aa2ff;      /* accents */
      --accent2:#ffb86b;     /* warm accent */
      --good:#5ee6a9;
      --pulse:#8bd5ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 70% -10%, #1a2250 0%, #0b1020 50%, #070b18 100%);
      color:var(--ink);
    }
    .frame{
      display:grid; grid-template-rows:auto 1fr auto; min-height:100%; gap:16px; padding:24px; max-width:1100px; margin:0 auto;
    }
    header{display:flex; align-items:center; gap:16px}
    .title{font-size:clamp(22px,2.4vw,28px); font-weight:800; letter-spacing:0.2px}
    .subtitle{color:var(--muted); font-size:14px}

    .stage{
      position:relative; background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.08); border-radius:20px; box-shadow:0 10px 40px rgba(0,0,0,0.35) inset, 0 30px 80px rgba(10,20,40,0.35);
      overflow:hidden;
    }
    .hud{
      position:absolute; inset:0; pointer-events:none;
    }
    .caption{
      padding:16px 18px; background:rgba(10,15,30,0.55); border-top:1px solid rgba(255,255,255,0.08);
      border-bottom-left-radius:20px; border-bottom-right-radius:20px;
    }
    .caption h2{margin:0; font-size:18px}
    .caption p{margin:6px 0 0; color:var(--muted)}

    .controls{display:flex; justify-content:space-between; align-items:center; gap:10px}
    .btns{display:flex; gap:10px}
    button{
      appearance:none; border:none; background:var(--panel); color:var(--ink);
      padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer; border:1px solid rgba(255,255,255,0.08);
      transition: transform .15s ease, box-shadow .2s ease, border-color .2s ease;
    }
    button:hover{ transform:translateY(-1px); box-shadow:0 8px 24px rgba(0,0,0,0.35); border-color:rgba(255,255,255,0.18)}
    button:active{ transform:translateY(0) scale(.98)}
    .chip{font-size:12px; padding:6px 8px; border-radius:10px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.08)}

    /* --- transitions --- */
    .fade-enter{opacity:0; transform:scale(0.98)}
    .fade-enter-active{opacity:1; transform:scale(1); transition: opacity .6s ease, transform .6s ease}
    .fade-exit{opacity:1}
    .fade-exit-active{opacity:0; transform:scale(1.02); transition: opacity .5s ease, transform .5s ease}

    /* Animated utility classes */
    .glow{filter: drop-shadow(0 0 12px rgba(138, 180, 255, 0.45));}
    .pulse{ animation:pulse 1.5s ease-in-out infinite }
    @keyframes pulse{ 0%{opacity:.7} 50%{opacity:1} 100%{opacity:.7}}
    .dash{ stroke-dasharray:6 8; animation:dashmove 3.5s linear infinite }
    @keyframes dashmove{ to{ stroke-dashoffset:-1000 } }

    /* Legend styles */
    .legend{ position:absolute; right:14px; top:14px; background:rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.08); padding:8px 10px; border-radius:12px; font-size:12px; color:var(--muted)}
    .legend b{ color:var(--ink) }
  </style>
</head>
<body>
  <div class="frame">
    <header>
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M12 2l2.7 5.5 6.1.9-4.4 4.3 1 6.1L12 16.8 6.6 18.8l1-6.1L3.2 8.4l6.1-.9L12 2z" stroke="var(--accent)" stroke-width="1.2"/>
      </svg>
      <div>
        <div class="title">NLP Evolution: Word2Vec → Transformers</div>
        <div class="subtitle">A bite-size animation across five phases</div>
      </div>
    </header>

    <div class="stage" id="stage" role="img" aria-label="Animated explanation of NLP evolution">
      <svg id="viz" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet" width="100%" height="100%"></svg>
      <div class="legend" id="legend"></div>
      <div class="hud" aria-hidden="true">
        <!-- corner glow -->
      </div>
    </div>

    <div class="controls">
      <div class="btns">
        <button id="prev">◀ Back</button>
        <button id="next">Next ▶</button>
        <button id="replay">↺ Replay</button>
      </div>
      <div>
        <span class="chip" id="stepChip">1 / 5</span>
        <span class="chip" id="statusChip">auto-play: on</span>
      </div>
    </div>

    <div class="caption" id="caption">
      <h2>Phase 1 — Word2Vec (Word Vector Representation)</h2>
      <p>Word2Vec maps words to vectors in a continuous space, preserving semantic relationships (e.g., "king" − "man" + "woman" ≈ "queen").</p>
    </div>
  </div>

<script>
(function(){
  const svg = document.getElementById('viz');
  const caption = document.getElementById('caption');
  const stage = document.getElementById('stage');
  const legend = document.getElementById('legend');
  const stepChip = document.getElementById('stepChip');
  const statusChip = document.getElementById('statusChip');
  const BTN = {prev:document.getElementById('prev'), next:document.getElementById('next'), replay:document.getElementById('replay')};

  const W = 1200, H = 520;
  let step = 0; // 0..4
  let timer = null; let autoplay = true;
  const DURATION = 6400; // ms per phase

  function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
  function setCaption(title, text){
    caption.classList.remove('fade-enter-active');
    caption.classList.add('fade-exit');
    caption.classList.add('fade-exit-active');
    setTimeout(()=>{
      caption.innerHTML = `<h2>${title}</h2><p>${text}</p>`;
      caption.className = 'caption fade-enter';
      requestAnimationFrame(()=>caption.classList.add('fade-enter-active'));
    }, 200);
  }
  function setLegend(html){ legend.innerHTML = html || ''; }
  function rand(min,max){ return Math.random()*(max-min)+min }

  // Helpers to build SVG
  const NS = 'http://www.w3.org/2000/svg';
  function el(tag, attrs={}, children=[]) {
    const n = document.createElementNS(NS, tag);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
    for (const c of [].concat(children)) n.appendChild(c);
    return n;
  }
  function text(x,y,str,opts={}){
    return el('text', Object.assign({x,y, 'font-size': opts.size||16, fill: opts.fill||'var(--ink)', 'font-weight': opts.bold?700:500, 'text-anchor': opts.anchor||'start', opacity: opts.opacity ?? 1}, opts.attrs||{}), [document.createTextNode(str)])
  }

  // ===== PHASE 1: Word2Vec =====
  function phase1(){
    clearSVG(); setLegend('<b>Concepts:</b> word cloud → vector space | <b>Relation:</b> analogies');
    const g = el('g', {transform:'translate(0,0)'});

    // word cloud
    const words = ['king','queen','man','woman','apple','orange','Paris','France','Rome','Italy','music','melody','dog','cat','happy','joy','car','vehicle'];
    const nodes = [];
    words.forEach((w,i)=>{
      const x = rand(100, 1100), y = rand(80, 440);
      const n = text(x, y, w, {size: 18+Math.random()*8, opacity:.92});
      n.style.transition = 'transform 1.4s cubic-bezier(.2,.8,.2,1), opacity .6s';
      n.style.transformOrigin = 'center';
      g.appendChild(n); nodes.push({el:n, word:w});
    });

    // axes for vector space
    const axes = el('g', {opacity:0});
    axes.appendChild(el('line', {x1:90,y1:H-80,x2:W-90,y2:H-80, stroke:'var(--muted)', 'stroke-width':1, class:'dash'}));
    axes.appendChild(el('line', {x1:120,y1:60,x2:120,y2:H-60, stroke:'var(--muted)', 'stroke-width':1, class:'dash'}));
    axes.appendChild(text(W-100,H-90,'x', {fill:'var(--muted)'}));
    axes.appendChild(text(110,70,'y', {fill:'var(--muted)'}));
    g.appendChild(axes);

    svg.appendChild(g);

    // transition: cloud → vectors
    setTimeout(()=>{ axes.setAttribute('opacity',1); }, 600);

    // deterministic pseudo-embeddings for layout (just for visuals)
    function embed(w){
      const map = {
        king:[0.82,0.75], queen:[0.86,0.78], man:[0.64,0.53], woman:[0.67,0.64],
        apple:[0.20,0.22], orange:[0.22,0.20], Paris:[0.45,0.73], France:[0.43,0.68], Rome:[0.52,0.66], Italy:[0.50,0.61],
        music:[0.10,0.78], melody:[0.13,0.80], dog:[0.78,0.18], cat:[0.74,0.22], happy:[0.30,0.70], joy:[0.34,0.74], car:[0.88,0.48], vehicle:[0.84,0.44]
      };
      return map[w] || [Math.random(),Math.random()];
    }

    setTimeout(()=>{
      nodes.forEach(({el,word})=>{
        const [ex,ey] = embed(word);
        const tx = 120 + ex*(W-240);
        const ty = (H-80) - ey*(H-160);
        el.style.transform = `translate(${tx - el.getAttribute('x')}px, ${ty - el.getAttribute('y')}px)`;
        el.style.opacity = 1;
      });
    }, 1200);

    // show the famous analogy as arrows
    const analogy = el('g', {opacity:0});
    function pointOf(w){
      const [ex,ey] = embed(w);
      return {x:120 + ex*(W-240), y:(H-80) - ey*(H-160)};
    }
    const K=pointOf('king'), M=pointOf('man'), Wm=pointOf('woman'), Q=pointOf('queen');
    const arrow = (a,b,color)=>{
      const dx=b.x-a.x, dy=b.y-a.y, len=Math.hypot(dx,dy), ang=Math.atan2(dy,dx)*180/Math.PI;
      const grp = el('g', {transform:`translate(${a.x},${a.y}) rotate(${ang})`});
      grp.appendChild(el('line',{x1:0,y1:0,x2:len-14,y2:0,stroke:color,'stroke-width':2, class:'dash'}));
      grp.appendChild(el('polygon',{points:`${len-14},-6 ${len-14},6 ${len},0`, fill:color, opacity:.9}));
      return grp;
    }
    analogy.appendChild(arrow(M,Wm,'var(--accent2)'));
    analogy.appendChild(arrow(K,Q,'var(--good)'));
    analogy.appendChild(text(Q.x+10,Q.y-10,'≈ queen',{fill:'var(--good)', size:14, bold:true}));
    svg.appendChild(analogy);
    setTimeout(()=> analogy.setAttribute('opacity',1), 2200);

    setCaption('Phase 1 — Word2Vec (Word Vector Representation)', 'Word2Vec maps words to vectors in a continuous space, preserving semantic relationships (e.g., "king" − "man" + "woman" ≈ "queen").');
  }

  // ===== PHASE 2: seq2seq =====
  function phase2(){
    clearSVG(); setLegend('<b>Concepts:</b> encoder → decoder | <b>Task:</b> translation');
    const g = el('g'); svg.appendChild(g);

    const input = 'the cat sits on the mat'.split(' ');
    const output = 'o gato senta no tapete'.split(' ');

    // Draw encoder tokens
    const encY = 170, decY = 360;
    const startX = 120, gap = 150;
    const encNodes = input.map((tok,i)=>{
      const x = startX + i*gap*0.75;
      const box = el('rect',{x:x-40,y:encY-24,width:80,height:40,rx:10,fill:'rgba(122,162,255,0.15)',stroke:'var(--accent)','stroke-width':1});
      const label = text(x, encY, tok,{anchor:'middle'});
      g.appendChild(box); g.appendChild(label);
      return {x,box,label};
    });

    // Draw decoder tokens placeholders
    const decNodes = output.map((tok,i)=>{
      const x = startX + i*gap*0.68;
      const box = el('rect',{x:x-40,y:decY-24,width:80,height:40,rx:10,fill:'rgba(255,184,107,0.15)',stroke:'var(--accent2)','stroke-width':1, opacity:.65});
      const label = text(x, decY, '…',{anchor:'middle', opacity:.6});
      g.appendChild(box); g.appendChild(label);
      return {x,box,label,tok};
    });

    // Encoder → context vector → Decoder
    const ctx = el('circle',{cx:W/2, cy:(encY+decY)/2, r:12, fill:'var(--pulse)', opacity:0});
    g.appendChild(ctx);

    // Animate flows
    setTimeout(()=>{
      ctx.setAttribute('opacity',1);
      encNodes.forEach((n,i)=>{
        const path = el('path',{d:`M${n.x},${encY+20} C ${n.x},${encY+60} ${W/2},${encY+40} ${W/2},${(encY+decY)/2-14}`,
          stroke:'var(--accent)', 'stroke-width':1.6, fill:'none', class:'dash', opacity:.9});
        g.appendChild(path);
      });
    }, 600);

    setTimeout(()=>{
      decNodes.forEach((n,i)=>{
        const path = el('path',{d:`M${W/2},${(encY+decY)/2+14} C ${W/2},${decY-40} ${n.x},${decY-60} ${n.x},${decY-24}`,
          stroke:'var(--accent2)', 'stroke-width':1.6, fill:'none', class:'dash', opacity:.9});
        g.appendChild(path);
        setTimeout(()=>{ n.label.textContent = n.tok; n.label.setAttribute('opacity',1); n.box.setAttribute('opacity',1); }, 260*i);
      });
    }, 1500);

    setCaption('Phase 2 — seq2seq (Sequential Modeling)', 'seq2seq models handle input and output sequences of varying lengths, essential for tasks like machine translation.');
  }

  // ===== PHASE 3: Attention =====
  function phase3(){
    clearSVG(); setLegend('<b>Concepts:</b> attention weights | <b>Visual:</b> heatmap highlights');
    const g = el('g'); svg.appendChild(g);

    const src = 'the cat sits on the mat'.split(' ');
    const tgt = 'o gato senta no tapete'.split(' ');

    const left = 220, top = 110, cell = 34;

    // labels
    src.forEach((t,i)=> g.appendChild(text(left - 10, top + i*cell + 18, t, {anchor:'end', size:14, fill:'var(--muted)'})));
    tgt.forEach((t,j)=> g.appendChild(text(left + j*cell + 16, top - 10, t, {anchor:'middle', size:14, fill:'var(--muted)'})));

    // grid cells
    const cells=[];
    for(let i=0;i<src.length;i++){
      for(let j=0;j<tgt.length;j++){
        const r = el('rect',{x:left + j*cell, y:top + i*cell, width:cell-2, height:cell-2, rx:5, fill:'rgba(122,162,255,0.10)', stroke:'rgba(255,255,255,0.06)'});
        r.style.transition='fill .45s ease, transform .25s ease';
        g.appendChild(r); cells.push({i,j, r});
      }
    }

    // simulate sweeping attention diagonally and jumping to nouns
    let k=0; const seq=[ [1,1],[2,2],[2,3],[3,3],[4,4],[5,5] ];
    function highlight(i,j){
      cells.forEach(c=> c.r.setAttribute('fill','rgba(122,162,255,0.10)'));
      cells.filter(c=> c.i===i && c.j===j).forEach(c=> c.r.setAttribute('fill','rgba(94,230,169,0.65)'));
      // soft neighborhood
      cells.filter(c=> Math.abs(c.i-i)+Math.abs(c.j-j)===1).forEach(c=> c.r.setAttribute('fill','rgba(139,213,255,0.45)'));
    }
    const walker = setInterval(()=>{
      const [i,j] = seq[k%seq.length]; k++; highlight(i,j);
      if(k>seq.length*3) clearInterval(walker);
    }, 420);

    // connection curves for a single decoding step
    const curves = el('g',{opacity:0});
    [[1,1],[2,2],[2,3]].forEach(([i,j],idx)=>{
      const sx = left + j*cell + 12, sy = top - 22;
      const tx = left - 12, ty = top + i*cell + 16;
      const p = el('path',{d:`M${sx},${sy} C ${sx},${sy+60} ${tx},${ty-60} ${tx},${ty}`, stroke:'var(--good)', 'stroke-width':1.4, fill:'none', class:'dash', opacity:0.9});
      curves.appendChild(p);
    });
    g.appendChild(curves);
    setTimeout(()=> curves.setAttribute('opacity',1), 900);

    setCaption('Phase 3 — Attention (Focus and Context)', 'The attention mechanism allows the model to focus on specific parts of the input when producing the output, capturing the broader context more effectively.');
  }

  // ===== PHASE 4: Transformers =====
  function phase4(){
    clearSVG(); setLegend('<b>Concepts:</b> multi-head attention + feed-forward | <b>Property:</b> parallelism');
    const g = el('g'); svg.appendChild(g);

    // draw stacked transformer blocks
    const blocks = [];
    const bx = 200, by = 90, bw = 800, bh = 70, gap = 26;
    for(let i=0;i<4;i++){
      const y = by + i*(bh+gap);
      const group = el('g');
      const base = el('rect',{x:bx, y, width:bw, height:bh, rx:18, fill:'rgba(255,255,255,0.04)', stroke:'rgba(255,255,255,0.10)'});
      const mha = el('rect',{x:bx+18, y:y+12, width:bw-36, height:24, rx:10, fill:'rgba(122,162,255,0.18)', stroke:'var(--accent)'});
      const ffn = el('rect',{x:bx+18, y:y+bh-36, width:bw-36, height:24, rx:10, fill:'rgba(94,230,169,0.18)', stroke:'var(--good)'});
      group.appendChild(base); group.appendChild(mha); group.appendChild(ffn);
      group.appendChild(text(bx+28, y+28, 'Multi-Head Attention', {size:14, fill:'var(--ink)'}));
      group.appendChild(text(bx+28, y+bh-20, 'Feed Forward', {size:14, fill:'var(--ink)'}));
      g.appendChild(group); blocks.push({group,mha,ffn});
    }

    // parallel heads depiction
    const heads = el('g'); g.appendChild(heads);
    for(let h=0; h<8; h++){
      const cx = bx + 100 + h*85, cy = by + 12 + 12;
      const p = el('circle',{cx, cy, r:6, fill:'var(--accent)', opacity:.75}); heads.appendChild(p);
    }

    // animate energy pulses through blocks
    const pulses = [];
    for(let i=0;i<12;i++){
      const px = bx + 40 + i*64; const c = el('circle',{cx:px, cy:by+bh/2, r:4, fill:'var(--pulse)', opacity:0});
      g.appendChild(c); pulses.push(c);
    }
    let t=0; const run = setInterval(()=>{
      pulses.forEach((c,idx)=>{
        const cy = by + (bh+gap)*( (t/4 + idx/12) % 4 ) + bh/2;
        c.setAttribute('cy', cy);
        c.setAttribute('opacity', 0.9);
        c.classList.add('pulse');
      });
      if(t++>28) clearInterval(run);
    }, 220);

    // residual connections (skip)
    const res = el('g');
    for(let i=0;i<3;i++){
      const y1 = by + i*(bh+gap) + bh - 12;
      const y2 = y1 + gap + 12;
      const path = el('path',{d:`M${bx+bw-26},${y1} C ${bx+bw+30},${y1} ${bx+bw+30},${y2} ${bx+bw-26},${y2}`, stroke:'rgba(255,255,255,0.25)','stroke-width':1.6, fill:'none'});
      res.appendChild(path);
    }
    g.appendChild(res);

    setCaption('Phase 4 — Transformers (The Transformer Breakthrough)', 'Transformers combine attention layers and parallel processing, enabling more efficient and flexible learning, as seen in models like BERT and GPT.');
  }

  // ===== PHASE 5: Connection & Impact =====
  function phase5(){
    clearSVG(); setLegend('<b>Concepts:</b> components together | <b>Impact:</b> Large Language Models');
    const g = el('g'); svg.appendChild(g);

    // central LLM node
    const center = {x: W/2, y: H/2};
    const core = el('circle',{cx:center.x, cy:center.y, r:56, fill:'rgba(122,162,255,0.15)', stroke:'var(--accent)', 'stroke-width':1.6, class:'glow'});
    const label = text(center.x, center.y+4, 'LLMs', {anchor:'middle', size:24, bold:true});
    g.appendChild(core); g.appendChild(label);

    // satellite nodes
    const nodes = [
      {name:'Word2Vec', color:'var(--accent2)'},
      {name:'seq2seq', color:'var(--accent2)'},
      {name:'Attention', color:'var(--good)'},
      {name:'Transformers', color:'var(--accent)'},
      {name:'BERT', color:'var(--accent)'},
      {name:'GPT', color:'var(--accent)'}
    ];
    const sats=[]; const R = 190;
    nodes.forEach((n, i)=>{
      const ang = (i / nodes.length) * Math.PI * 2 - Math.PI/2;
      const x = center.x + Math.cos(ang)*R; const y = center.y + Math.sin(ang)*R;
      const c = el('circle',{cx:x, cy:y, r:28, fill:'rgba(255,255,255,0.06)', stroke:n.color, 'stroke-width':1});
      const l = text(x, y+4, n.name, {anchor:'middle', size:14});
      g.appendChild(c); g.appendChild(l);
      const link = el('path',{d:`M${center.x},${center.y} L${x},${y}`, stroke:n.color, 'stroke-width':1.2, class:'dash', opacity:0.85});
      g.insertBefore(link, c); sats.push({c,l,link});
    });

    // pulses moving along links
    const dots=[]; sats.forEach((s,idx)=>{
      const d = el('circle',{r:5, fill:'var(--pulse)', opacity:0}); g.appendChild(d); dots.push({d, idx});
    });
    let tt=0; const loop = setInterval(()=>{
      sats.forEach((s, i)=>{
        const ang = (i / sats.length) * Math.PI * 2 - Math.PI/2;
        const t = ( (tt + i*6) % 100 ) / 100; // 0..1
        const x = center.x + Math.cos(ang)*R*t; const y = center.y + Math.sin(ang)*R*t;
        const dot = dots[i].d; dot.setAttribute('cx', x); dot.setAttribute('cy', y); dot.setAttribute('opacity', 0.95);
      });
      if(tt++>220) clearInterval(loop);
    }, 60);

    setCaption('Phase 5 — Connection and Impact', 'The transition from Word2Vec to Transformers represents a significant leap in how we understand and process natural language more accurately and efficiently. Today, these advances power large-scale NLP models (LLMs) like GPT.');
  }

  // ===== controller =====
  const phases = [phase1, phase2, phase3, phase4, phase5];

  function go(i){
    step = ( (i%phases.length)+phases.length ) % phases.length;
    stepChip.textContent = (step+1) + ' / ' + phases.length;
    stage.classList.remove('fade-enter-active');
    stage.classList.add('fade-exit'); stage.classList.add('fade-exit-active');
    setTimeout(()=>{
      stage.className = 'stage fade-enter';
      phases[step]();
      requestAnimationFrame(()=> stage.classList.add('fade-enter-active'));
    }, 180);
    if (timer){ clearInterval(timer); timer=null; }
    if (autoplay){ timer = setInterval(()=> go(step+1), DURATION); }
  }

  BTN.next.onclick = ()=>{ autoplay=false; statusChip.textContent='auto-play: off'; go(step+1); };
  BTN.prev.onclick = ()=>{ autoplay=false; statusChip.textContent='auto-play: off'; go(step-1); };
  BTN.replay.onclick = ()=>{ autoplay=true; statusChip.textContent='auto-play: on'; go(0); };

  // kick off
  go(0);
})();
</script>
</body>
</html>

